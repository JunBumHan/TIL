오늘도 마찬가지로 Go 언어를 학습했다. 
오늘은 구조체, 포인터, 문자열, 패키지(다 못함 이해 못학겠음 내일 해야 할 것 같다.)에 대해 배웠다.

그냥 자고 싶다. 현타 오고 힘들다. 너무 놀았다. 내일부터 열심해 해야 겠다. 
아니 열심히 한다고 해놓고 또 놀거잖아
하 짜증난다.
ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ아 이해가 안 된다. ㅠㅠ 짜증나낟. 알넘ㄹ;이ㅓ

오늘 한거 올린다.

- ### 구조체
```
/*
	구조체는 여러 필드를 묶어서 사용하는 타입이다.
	이름, 나이 등을 묶어서 학생 구조체 데이터를 만들 수 있습니다.

	장점으로는
	1. 구조체를 사용하면 관련 데이터를 묶어서 하나의 변수로 다룰 수 있다.
	2. 개별 데이터보다는 관련 데이터가 묶인 객체 단위로 코딩할 수 있게 해준다.
	3. 구조체를 사용하면 여러 값을 손쉽게 다른 함수로 전달할 수 있다.

	GolangG 에서 구조체를 선언하기 위해서는 아래와 같은 형태를 지켜 선언합니다.

	type 구조체명 struct {
		필드명 타입
		...

	}

	1. type 키워드는 새로운 사용자 정의 타입을 정의한다는 키워드 입니다.
	그 다음 구조체명 적어줍니다.

	그러면 구조체를 묶어 주도록 하겠습니다.

	구조체 필드에 접근하기 위해서는 `.`을 사용해 접근 할 수 있습니다.


	# 구조체 변수 초기화
		구조체 변수를 선언하고 각 필드를 초괴하는 방법을 알아보자
		방법으로는 [초깃값 생략], [모든 필드 초기화], [일부 필드 초기화] 방법이 존재합니다.

		### 초깃값 생략
		초깃값을 생략하면 모든 필드가 기본값으로 초기화 됩니다.

		### 모든 필드 초기화
		모드 필드값을 중괄호 사이에 넣어서 초괴화 합니다.
		1. var me JunBum = JunBum{"JunBum", 18, 192}
		2. var me JunBum = JunBum{
			"JunBumHan",
			18,
			192,
		}
		중요한 점은  필드 순서와 입력한 순서에 맞춰 일대일 매칭되어 초기화 된다는 점 입니다.

		### 일부 필드 초기화
		일부 필드값만 초기화할 때는 '필드명:필드값' 형식으로 초기화 합니다. 초기화되지 않은 나머지 변수에는 기본값이 할당됩니다.
		1. var me JunBum =  JunBum{Name:"JunBuMHan", Height:123}
		2. var me JunBum = JunBum{
			Name : "JunBumHan",
			Height: 123,
		}

		### 구조체를 포함하는 구조체
		구조체의 필드로 다른 구조체를 포함할 수 있습니다.
		방법은 [내장 타입], [포함된 필드] 방식이 존재합니다.

		1. 내장 타입
		말 그대로 구조체 필드를 선언할 때, 구조체를 타입으로 적어주면 됩니다.

		2. 포함된 필드
		내장 타입 방법을 사용하면 , 두 단계 걸쳐 접근해야 하는 필드가 생기게 됩니다.
		위 사실이 싫다면, 구조체에서 다른 구조체를 필드로 포함할 때 필드명을 생략하고 구조체명을 적어주면 됩니다.
		점 .을 두번 찍을 필요 없이 한 번만으로 접근 할 수 있기에 편리합니다.

		### 필드 중복 해결
		만약 포함된 필드 안에 속 필드명과 상위 구조체의 필드명이 서로 겹치는 경우 어떻게 될까요?
		해결 방법은
		현재 변수 타입에 해당하는 구조체의 필드에 접근해서 해야 합니다.
		아래 예제를 보면
		type A struct {
			a int
			B
		}

		type B struct {
			a int
		}

		이렇게 했을 경우
		var sturct_A A = A{24, B{5}}
		fmt.Println(sturct_A.a, sturct_A.B.a)
		이렇게 해결합니다.

		### 구조체 크기
		그냥 필드 데이터 타입의 바이트 수를 다 더해주면 된다.

		### 구조체 값 복사
		구조체 변숫값을 다른 구초제에 대입하면 모든 필드값이 복사됩니다.


		### 필드 배치 순서에 따른 구조체 크기 변화
		메모리 정렬 때문에 좀 더 큰 메모리 값으로 출려됨

		### 메모리 정렬
		메모리 정렬이란 컴퓨터가 데이터에 효과적으로 접근하고자 메모리를 일정 크기 간격으로 정렬하는 것을 말합니다.
		레지스터 크기에 따라서 컴퓨터의 성능이 달리진다. 현재 64비트 컨퓨터 기준으로 CPU의 계산은 8byte 단위로 계산이 이루어진다.
		여기서 메모리에 있는 걸 8단위로 정렬 시키면, 성능상 매우 좋아질 것이다.
		그래서 메모리 정렬 개념이 생긴 거고, 패링이 생긴 이유다.


		그러면 어떻게 패링을 적게 구조체를 선언할 수 있을까요>?
		바로 8 바이트보다 작은 필드는 8바이트 크기를 고려해서 몰아서 배치하는 것 입니다.

		메모리 공간이 작은 임베디드 하드웨어에서 돌아가는 것은 패링을 고려해야 한다.

		### 프로그래밍에서 구조체의 역활
		프로그래밍 역사는 객체 간 결합도는 낮추고 연관있는 데이터 간 응집도를 올리는 방향으로 흘러왔다.
		결합도(의존성)은 낮게 낮게 응집도는 높게 -> 곤련도가 낮은것은 묶여 있으면 안되고, 관련있으면 묶어야 한다.]\
		low coupling, high cohesion

		coupling :  학교는 선생이 필요하다. 학교가 없어지면 선생은 살아있는가?  만약 선생이 살아있으면 decoupling, 죽었으면 coupling

		구조체는 응집도를 높이게 해준다.
		- 함수는 관련 코드 블록을 묶어서 응집도를 높이고 재사용성을 증가시킨다.
		- 배열은 같은 타입의 데이터들을 묶어서 응집도를 높인다.
		- 구조체는 관련된 데이터들을 묶어서 응집도를 높이고 재사용성을 높인다.

		구조체가 등장하기 전, 사람들을 개별 데이터에 집중하며 코딩을 작업을 진행했습니다.
		그러나 구조체가 등장하고 많은 프로그래머들은 구조체 간의 관계와 상호작용 중심으로 변화하게 되었습니다.
		그 후 메서드, 인터페이스, 개념이 추가되면서 객체지향 프로그램으로 발전했습니다.


*/

package main

import "fmt"

type A struct {
	a int
	B
}

type B struct {
	a int
}

type User struct {
	ID  string
	Age int
}

type VIPUser struct {
	User
	VIPLevel int
	Age      int
}

func main() {

	var sturct_A A = A{24, B{5}}
	fmt.Println(sturct_A.a, sturct_A.B.a)

}
```
- ### 포인터ㅓ
```
/*
	포인터는 메모리 주소를 값으로 갖는 타입 입니다.
	포인터를 이용하면 동일한 메모리 공간을 여러 변수가 가릴킬 수 있습니다.

	포인터를 이용하면 메모리 복사를 줄일 수 있습니다.
	포인터를 이용하면 반환값 없이 변숫값을 바꿀 수 있습니다.

	# 포인터란
		메모리 주소를 값으로 갖는 타입 입니다.
		변수 a의 주소가 0x0100 번지라고 했을 때 메로리 주소값 또한 숫자값이기 때문에 다른 변수의 값으로 사용될 수 있다.
		이렇게 메모리 주솟값을 변숫값으로 가질 수 있는 변수를 포인터 변수라고 한다.

		포인터를 이용하면 여러 포인터 변수가 하나의 메모리 공간을 가리킬 수도 있고 포인터가 가리키고 있는 메모리 공간의 값을 읽을 수도 변경할 수도 있다.

	# 포인터 변수 선언
		포인터 변수는 가리키는 데이터 타입 앞에 *을 붙여서 선언합니다.
		var p *int

	# 포인터의 기본값 nil
		포인터 변숫값을 초기화하지 않으면 기본값은 nil 입니다. 이 값은 0이지만 정확한 의미는 요효하지 않은 메모리 주솟값을 뜻합니다. 즉 어떤 메모리 공간도 가리키고 있지 않음을 나타냅니다.

		var p *int
		if p != nil {
			p가 가리키고 있ㄷ.
		}

	# 그러면 포인터 왜 사용하냐?
		그럼 포인터를 언제 사용해야 하나?
		- 변수 대입이나 함수 인수 전달은 함상 값의 복사로만 이루어 진다. 그렇기에 많은 메모리 공간을 사용하는 문제와 큰 메모리 공간을 복사할 때 발생하는 성능 문제를 갇고 있다.
		- 또한 다른 공간으로 복사되기 떄문에 변경 사항이 적용되지 읺는다.
		즉 포인터는 위 문제를 해결하기 위해서 사용한다고 말할 수 있다.

	#  Data 구조체를 생성해 포인터 변수 초기화 하기
		구조체 변수를 별도로 생성하지 않고, 곧바로 포인터 변수에 구조체를 생성해 주소를 초깃값으로 대입하는 방벙블 알아보자
		var data Data
		var p *Data = &data

		이렇게 작성한 코드를

		var p *Data = &Data{}
		-> Data 구조체를 만들어 주소를 반환한다.


	# 인스턴스
		인스턴스란 메모리에 할당된 데이터의 실체를 말합니다.

		var data Data -> Data 타입값을 저장할 수 있는 메모리 공간을 할당한다.
		이렇게 할당된 메모리 공간의 실체를 인스턴스라 할 수 있다.
		(실체 ㅣ 실제의 물체)
		(물체 | 구체적인 형태를 가지고 있는 것.)

		var data Data
		var p *Data = &data
		위 코드의 Data 인스턴스의 총 갯수는 1개이다.

		여기서 저자가 말하고 싶은 것은 포인터 변수를 선언해도 인스턴스가 늘어나는 것이 아닌,
		인스턴스를 가리키는 변수들만 들어난다는 점 입니다.
		즉, 가리키는 포인터 변수 개수는 인스턴스 개수와 무관하다 볼 수 있습니다.

	# 인스턴스는
		구조체 포인터를 함수 매개변수로 받는다.
		-> 구조체 인스턴스를 입력 받겠다.

		구조체를 함수 매개변수로 받는다.
		-> 구조체 인스턴스의 복사본을 입력 받겠다.

	# new() 내장 함수
		앞어 포인터값을 별도의 변수를 선언하지 않고 초기화하는 방법을 봤다.
		1. new 내장 함수를 이용하는 방법
			var p2 new(Data)
			-> 필드 값을 초기화 할 수 없습니다.

		2. &를 사용하기
			var p3 = new(Data) [:=]
			-> 필드 값을 초기화 활 수 있다.

		아 둘은 모두 다 자주 사용하기 때문에, 잘 알아 두셔야 합니다.

	# 인스턴스는 언제 사라지나
		"메모리는 무한한 자원이 아니다."
		그렇기에 Go 에서는 가비지 컬렉터가 메모리 청소를 합니다.

		u := &User{}
		u.Age = 30
		fmt.Println()

		User 인스턴스는 u의 의존하게 됩니다. 왜냐하면 u가 User 구조체를 가리키 때문이죠
		그럼 만약 위 함수가 종료되면 User 구조체는 어떻게 될까요?
		네, 가바지 컬렉터가 정리해줍니다. 하지만 세상에는 공짜가 없습니다. 그만큼 성능에서 손해가 발생합니다.

		- 인스턴스는 메모리에 생성된 데이터의 실체이다.
		- 포인터를 이용해서 인스턴스를 가리키게 할 수 있다.
		- 함수 호출 시 포인터 인수를 통해서 인스턴스를 입력받고 그 값을 변경할 수 있다.
		- 쓸모 없어진 인스턴스는 가바지 컬렉터가 자동으로 채워준다.

	# 스택 메모리와 힘 메모리
		대부분 프로그래밍 언어는 메모리를 할당할 때 스택 메모리 영역 또는 힙 메모리 영역을 사용합니다.
		이론상 스택 메모리 영역이 힙 메로리 영역보다 훨씬 효율적 이기 때문에, 스택 메모리 영역에서 메모리를 할당하는게 더 좋지만, 스택 메모리 함수 내부에서만 사용 가능하다.
		Go언어는 타출 검사를 해서 어느 메모리에 할당할 지를 결정합니다.

		func newUser(name string, age int) * User {
			var u = User {name, age}
			return &u
		}
		이 코드의 경우 c/c++ 에서는 이미 사리진 메모리를 가리키는 댕글링 오류가 난다. -> 그니깐 u의 수명은 중괄가 끝나기 전인데, 수명이 끝날 구조체 포인터를 반환하다.?? 이상하네 즉 무효한 주소가 된다라는 뜻인데,
		Golang 에서는 타출 검사를 통해서 User 를 stack에 쌓는 것이 아닌, heap 영역에 할당하게 된다. 이처럼 Golang에서는 탈출 검사를 통해 stack에 저장할지, heap에 저장할 떄 사라진다.
		그러면 heap 영역에 있는 인스턴스는 언제 사라지냐? 바로 쓰임이 없어질때 사라진다고 볼 수 있다.

		그니깐, 위 인스턴스는 언제 사라지냐에 따르면 변수의 수명은 {}에 따르게 된다.

	# 요약
		포인터는 메모리 주소를 값으로 갖는 타입이다.
		&를 이용해서 데이터의 메모리 주소를 알 수 있다.
		포인터를 이요하면 메모리 주소값으로 메모리를 조작할 수 있다.
		인서턴스는 메모리에 있는 데이터 실체이고 포인터로 조작할 수 있다.
		Go는 탈출 분석을 통해 인스턴스를 스택 메모리에 할당할지 힙 메모리에 할당할지 결정하낟.

*/

package main

import "fmt"

type Data struct {
	value int
	data  [200]int
}

func main() {
	// var p = &Data{}
	var p1 = new(Data)

	fmt.Println(p1.value, p1.data[100])
}
```
- ### 문자열
```
package main

/*
문자열이란 문자의 집합을 의미한다.
Golang 에서는 UTF-8 문자코드를 사용합니다.
UTF-8 문자코드는 유니코드의 일종으로 가변 길이 문자 문자 인코딩 방식입니다.

# 문자열

	문자열은 말 그대로 문자 집합이다.
	type은 string이다.
	"문자열"은 큰따옴표나, `백쿼트`로 묶어서 사용합니다.


	백쿼트로 문자열을 묶으면 문자열 안의 특수 문자가 일반 문자처럼 처리 된다. -> \n, \t

	one := "나는\t너무\n좋다"
	two := `나는	너무
	좋다`

# UTF-8 문자코드

	Golang 에서는 UTF-8 문자코드를 표준 문자코드로 사용합니다.
	-> 한글 한자를 사용 가능

# rune 타입으로 한 문자 답기

	문자 하나를 표현하는데 rune 타입을 사용합니다. utf-8은 한 글자가 1~3바이트 크기 이기 때문에 UTF-8 문자값을 가지려면 3바이트가 필요합니다.
	그래서 Golang은 int32 타입의 별칭인 rune 타입을 제공합니다.

# len() 으로 문자열 크기 알아내기

	len() 내장 함수를 이용해서 문자열 크기를 알 수 있습니다.
	이때 크기는 문자 함수가 아닌, 말 그대로 문자열이 차지하는 메모리 크기 입니다.
	-> len() 함수는 바이트 크기를 출력한다.

# []rune 타입 변환으로 글자 수 알아내기

	str := "Hello WOrld"

	runes := []rune(str)
	len([]rune{...}) -> 요소 갯수 반환
	len(str) -> 바이트 수 반환


	Golang 에서 완전히 다른 두 타입 (string, rune[])을 편의를 위해 상호 타입 변화를 지원하고 있습니다.

# string 타입을 []byte로 타입 변환할 수 있다.

	string  타입과 []byte 타입은 상호 타입 변환이 가능합니다.

# 문자열 순회

	문자열에 들어있는 글자들을 순회하는 방법을 알아봅시다. 문자열을 순회하는 방법은 크게 3가지 입니다.
	1. 인덱스를 사용한 바이트 단위 순회
	2. []rune으로 타입 변환 후 한 글자씩 순회
	3. range 키워드를 이용한 한 글자씩 출력

	1. 인덱스를 사용한 바이트 단위 순회

	func main() {
		str := "Hello World!"

		for i := 0; i < len(str); i++ {
			fmt.Printf("%c ", str[i])
		}
	}
	-> 한글을 순회할 수 없다.

	2. []rune 으로 타입 변환 후 한 글자씩 순회
	func main() {
		str := "Hello! 월드"
		arr := []rune(str)

		for i := 0; i < len(arr); i++ {
			fmt.Printf("%c", arr[i])
		}
	}
	-> 불필요한 메모리가 사용된다.

	위 두 단점을 보안한 것이 이 방법입니다.
	3. range 키워드를 이용한 한 글자씩 출력
	func main() {
		str1 := "Hello 월드!"

		for _, v := range str1 {
			fmt.Printf("%c", v/)
		}
	}
	-> 이처럼 range를 이용하면 추가 메모리 할당 없이 문자열을 한 글자씩 출력할 수 있습니다.

# 문자열 합치기
	문자열은 +와 +=연산을 사용해서 문자열을 이을 수 있습니다.
	func main() {
		str1 := "Hello"
		str2 := "World"

		str3 := str1 + " " + str2

		fmt.Println(str3)

		str1 += " " + str2 // 덧붙인다.

	}
	// -나 *연산자는 제공되지 않는다.

#문자열 비교하기
	==, !=를 이용해 두 문자열이 같은지 같지 않은지 확인 할 수 있다.

	func main() {
		str1 := "Hello"
		str2 := "Hell"

		fmt.Printf("%v", str1 != str2)
		fmt.Printf("%v", str1 == "Hello")
	}

#문자열 대소 비교하기
	>, <, >=, <=  연산자를 이용해서 문자열 간 대소고를 비교할 수 있습니다.
	문자열 대소 비교는 첫 글자부터 하나씩 값을 비교해서 그 글자에 해당하는 유니코드 값이 다를 경우 대소를 반환합니다.
	값이 같을 경우 다음 글자를 비교합니다.

	func main() {
		fmt.Printf("%v", "BBB" > )
	}

	문자열 대소 비교 시 문자열 길이와 상관없이 앞글자부터 비교합니다.

# string 구조 알아보기
	string 타입은
	Data, Len 두 필드의 구조체 이다.

# 문자열은 불변이다.
	문자열은 불변입니다. -> string 타입이 가리키는 문자열의 일부만 변경할 수 없다는 말입니다.
	그렇기에 아래의 코드는 불가능 합니다.
	str := "HellO"
	str[3] = "a"

# 문자열 합산
	Golang 언어에서 string 타입 간 합 연산을 지원합니다.


*/
```
- ### 패키지
```
노션 참고해달라.
```
하.. ㅋㅋ 지금 내가 이걸 하는게 맞나? 아 모르겟다. 그래도 goalng 잼있다. 너무 좋다. 자바 싫다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ
아오 오늘 멘타 ㅋㅋㅋ 
수고했다 즐겁게 공부하자!



